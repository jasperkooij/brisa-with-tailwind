async function $(j,H,q){if(j.nodeType!==H.nodeType)return q[0](()=>j.parentNode.replaceChild(H.cloneNode(!0),j));if(j.nodeType===1)await F(j,H,q),q[0](()=>{if(j.nodeName===H.nodeName){if(H.nodeName!=="BODY")U(j.attributes,H.attributes)}else{const z=H.nodeName==="TEMPLATE",J=H.cloneNode(z);while(j.firstChild)J.appendChild(j.firstChild);j.parentNode.replaceChild(J,j)}});else if(j.nodeValue!==H.nodeValue)q[0](()=>j.nodeValue=H.nodeValue)}function U(j,H){let q,z,J,V,X;for(q=j.length;q--;)if(z=j[q],V=z.namespaceURI,X=z.localName,J=H.getNamedItemNS(V,X),!J)j.removeNamedItemNS(V,X);for(q=H.length;q--;){if(z=H[q],V=z.namespaceURI,X=z.localName,J=j.getNamedItemNS(V,X),z.name==="data-action")continue;if(!J)H.removeNamedItemNS(V,X),j.setNamedItemNS(z);else if(J.value!==z.value)J.value=z.value}}async function F(j,H,q){let z,J,V,X,Y=null,Q=j.firstChild,B=await q[1](H),Z=0;while(Q)if(Z++,z=Q,J=D(z),Q=Q.nextSibling,J){if(!Y)Y={};Y[J]=z}Q=j.firstChild;while(B){let M;if(Y&&(V=D(B))&&(X=Y[V])){if(delete Y[V],X!==Q)q[0](()=>j.insertBefore(X,Q));else Q=Q.nextSibling;await $(X,B,q)}else if(Q)if(z=Q,Q=Q.nextSibling,D(z))M=B.cloneNode(!0),q[0](()=>j.insertBefore(M,z));else await $(z,B,q);else M=B.cloneNode(!0),q[0](()=>j.appendChild(M));if(M?.nodeType===1)await $(M,B,q);if(B=await q[2](B),!M)Z--}q[0](()=>{for(J in Y)Z--,j.removeChild(Y[J]);while(--Z>=0)j.removeChild(j.lastChild)})}function D(j){return j?.getAttribute?.("key")||j.id}async function W(j,H={}){const q=document.implementation.createHTMLDocument();q.open();const z=new TextDecoderStream,J=z.readable.getReader();let V=!0;j.pipeTo(z.writable),X();async function X(){try{while(!0){const{done:B,value:Z}=await J.read();if(B){V=!1;break}q.write(Z)}}finally{q.close()}}while(!q.documentElement||Q(q.documentElement))await E();function Y(B){return async(Z)=>{if(!Z)return null;let M=Z[B];while(H.shouldIgnoreNode?.(M))M=M[B];if(M)H.onNextNode?.(M);const G=B==="firstChild";while(Q(M,G))await E();return M}}function Q(B,Z){if(!B||!V||B.nextSibling)return!1;if(R.has(B.nodeName))return!q.body?.hasChildNodes?.();let M=B.parentElement;while(M){if(M.nextSibling)return!1;M=M.parentElement}return Z?V:V&&!B.hasChildNodes?.()}return{root:q.documentElement,[1]:Y("firstChild"),[2]:Y("nextSibling"),[0]:(B)=>{if(H.transition&&document.startViewTransition)window.lastDiffTransition=document.startViewTransition(B);else B()}}}var R=new Set(["HTML","HEAD","BODY"]),E=()=>new Promise((j)=>requestAnimationFrame(j));async function T(j,H,q){const z=await W(H,q),J=z.root;if(j.nodeType===9)j=j.documentElement;if(J.nodeType===11)await F(j,J,z);else await $(j,J,z)}export{T as default};
